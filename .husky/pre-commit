#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# Get the repository root directory
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Track if any checks failed
FAILED=0

# Run lint-staged for frontend if there are staged changes in apps/web
if git diff --cached --name-only --diff-filter=ACM | grep -q "^apps/web/"; then
	echo "üîç Running frontend checks..."
	if ! (cd apps/web && npx lint-staged); then
		echo "‚ùå Frontend checks failed"
		FAILED=1
	fi
fi

# Run Go formatting and checks if there are staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep "^apps/api/.*\.go$" || true)

if [ -n "$STAGED_GO_FILES" ]; then
	echo "üîç Running Go formatting and checks..."
	
	# Check if go is available
	if ! command -v go >/dev/null 2>&1; then
		echo "‚ö†Ô∏è  Warning: 'go' command not found. Skipping Go checks."
	else
		cd apps/api
		
		# Format all Go files in packages containing staged files
		# go fmt works on packages, so we format the entire module
		# This is fast and ensures consistency
		if ! go fmt ./...; then
			echo "‚ùå Go formatting failed"
			FAILED=1
		fi
		
		# Re-stage any files that were formatted
		# This ensures formatted code is included in the commit
		for file in $STAGED_GO_FILES; do
			git add "$file" 2>/dev/null || true
		done
		
		# Run go vet to catch common errors
		if ! go vet ./...; then
			echo "‚ùå Go vet found issues. Please fix them before committing."
			FAILED=1
		fi
		
		if [ $FAILED -eq 0 ]; then
			echo "‚úÖ Go checks passed"
		fi
		
		cd "$REPO_ROOT"
	fi
fi

# Exit with error if any checks failed
if [ $FAILED -eq 1 ]; then
	echo ""
	echo "üí° Tip: Fix the issues above or use 'git commit --no-verify' to skip hooks (not recommended)"
	exit 1
fi
